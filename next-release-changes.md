- introduce `t/Instance` and `t/Satisfies`
  - `t/Instance` provides classes with invariant type parameters with a common super type
    - e.g., `(t/Instance Comparable)` is a supertype of `(Comparable Any)`
  - similar for `t/Satisfies`, but for protocols
  - helpful for the return filters of `instance?` and `satisfies?`
    - i.e., we learn `(t/Instance Comparable)` if `(instance? Comparable ..)`, not `(Comparable Any)`
- add Class <: Protocol, DataType <: Protocol cases to constraint generation
- fix Class <: Protocol subtyping case
- assert that annotation is required when extending invariant protocols with deftype
- fix intersection simplication after change in 1.1.5
  - `(I Int (Nilable Int)) => Int`, not `(Nilable Int)`
- resolve first argument to `override-class` at runtime
- improve Java 21 support
  - annotate `java.util.SequencedCollection` and extend in `java.util.List`
- Breaking: remove `t/Var2`, change `clojure.lang.Var to take only 1 type parameter
  - use `t/AnyVar` for `(t/Var2 t/Nothing t/Any)`
- Deprecate `t/Var1`
  - use `t/Var`
- Breaking: remove `t/Ref2`, change `clojure.lang.Ref to take only 1 type parameter
  - use `t/AnyRef` for `(t/Ref2 t/Nothing t/Any)`
- Deprecate `t/Ref1`
  - use `t/Ref`
- Breaking: remove `t/Agent2`, change `clojure.lang.Agent to take only 1 type parameter
  - use `t/AnyAgent` for `(t/Agent2 t/Nothing t/Any)`
- Deprecate `t/Agent1`
  - use `t/Agent`
- Breaking: remove `t/Atom2`, change `clojure.lang.Atom to take only 1 type parameter
  - use `t/AnyAtom` for `(t/Atom2 t/Nothing t/Any)`
- Deprecate `t/Atom1`
  - use `t/Atom`
- Breaking: remove `t/Volatile2`, change `clojure.lang.Volatile to take only 1 type parameter
  - use `t/AnyVolatile` for `(t/Volatile2 t/Nothing t/Any)`
- add `t/AnySeqable` and `t/AnyNilableNonEmptySeq`
- don't use `resolve` to qualify first argument of `t/ann-protocol`
  - just qualify based on current namespace aliases
  - allows for annotations on protocols without a corresponding `defprotocol`
